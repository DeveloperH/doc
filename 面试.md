* [面试参考题目](https://mp.weixin.qq.com/s/xrJe87S-8rCP7QyrSGm8wA)





## HTML

### H5新增特性

新增标签：`header footer main nav article aside audio video canvas ` 等等

新增属性：`contenteditable` 规定元素内容是否可编辑

新增 `Geolocation` 地理定位、`localStorage` 和 `sessionStorage` 本地存储。



### H5全局属性

全局属性是可与所有HTML元素一起使用的属性。

* **id** : 规定元素的唯一 id。
* **class** : 规定元素的一个或多个类名（引用样式表中的类）。
* **style** : 规定元素的行内 CSS 样式。style 属性将覆盖任何全局的样式设定。
* **title** : 规定有关元素的额外信息。当鼠标移到元素上时显示一段工具提示文本。
* **data-*** : 用于存储页面或应用程序的私有定制数据。
  * 属性名不应该包含任何大写字母，并且在前缀 "data-" 之后必须有至少一个字符
  * 属性值可以是任意字符串
* accesskey : 规定激活（使元素获得焦点）元素的快捷键。
  * 使用alt+accesskey 或 alt+shift+accesskey 来访问带有快捷键的元素
  * 支持的元素：a,button,input,label,textarea等等
* contenteditable : 规定元素内容是否可编辑。
  * true规定元素可编辑。 / false规定元素不可编辑。
  * 如果元素未设置 contenteditable 属性，那么元素会从其父元素继承该属性。
* dir : 规定元素中内容的文本方向。
  * ltr(默认。从左向右的文本方向) / rtl(从右向左的文本方向)
* draggable : 规定元素是否可拖动。链接和图像默认是可拖动的。
  * auto(使用浏览器的默认行为) / true(可拖动) / false(不可拖动)
* hidden : 规定元素隐藏。如果元素还设置了`display`样式，该属性会被覆盖，从而失效。
* tabindex : 规定元素的 tab 键次序。值为number，1是第一个。
* lang : 规定元素内容的语言。zh/en/...
* spellcheck : 规定是否对元素进行拼写和语法检查。值为true/false



### 语义化理解

根据内容的结构选择适合的标签，这样做的好处有：

1. 结构清晰，更具可读性，便于团队开发维护
2. 利于SEO
3. 方便其他设备渲染网页(盲人阅读器等)

这些标签有：`header footer main nav` 等等



## CSS

### 水平垂直居中

实现一个 div 在不同分辨率下的水平垂直居中

```css
.box {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

  width: 100px;
  height: 100px;
  background-color: red;
}
```



### 左右固定，中间自适应

```css
.box {
  display: flex;
  height: 200px;
}
.left {
  flex: 0 0 100px;
  background-color: red;
}
.right {
  flex: 0 0 100px;
  background-color: blue;
}
.center {
  flex: 1;
  background-color: green;
}
```



### 清除浮动

给父元素使用 `::after` 伪元素

```css
.box::after {
  content: '';
  clear: both;
  display: block;
}
```





### 移动端1px边框

#### 伪类 + transform

原理：把原先元素的 border 去掉，然后利用 `::before 或者 ::after` 重做 border，并使用 transfrom 的 scale 将宽度缩小一半。原先的元素相对定位，新做的 border 绝对定位。

```css
/* 下边框1px */
.box::after {
  content: '';
  background-color: #000;
  position: absolute;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 1px;
  transform: scaleY(0.5);
  transform-origin: 0 0;
}
```

```css
/* 边框1px */
.box::after {
  content: '';
  border: 1px solid black;
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
}

/* 通过设备像素比设置对应的缩放 */
@media (-webkit-min-device-pixel-ratio: 2) {
  .box::after {
    width: 200%;
    height: 200%;
    transform: scale(0.5);
    transform-origin: 0 0;
  }
}
```



#### viewport + rem

同时通过设置对应`viewport`的`rem`基准值，这种方式就可以像以前一样轻松愉快的写`1px`了。

```html
<!-- 在devicePixelRatio=2 时，设置meta： -->
<meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no">

<!-- 在devicePixelRatio=3 时，设置meta： -->
<meta name="viewport" content="width=device-width, initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no">
```



通过js自动设置

```html
<script>
  let viewport = document.querySelector('meta[name=viewport]')
  let dpr = window.devicePixelRatio || 1
  let scale = 1 / dpr
  viewport.setAttribute('content', `width=device-width, initial-scale=${scale}, maximum-scale=${scale}, minimum-scale=${scale}, user-scalable=no`)

  document.documentElement.style.fontSize = window.innerWidth / 750 * 100 + 'px'
</script>
<style>
  html {
    font-size: 100px;
  }
  .box {
    width: 1rem;
    height: 1rem;
    border: 1px solid black;
    font-size: 0.16rem;
  }
</style>
```





### margin重合

相邻两个盒子垂直方向上的 margin 会发生重叠，只会取比较大的 margin

解决方案：

* 内层元素设置 `display: inline-block;`
* 外层元素设置 `overflow: hidden;`
* 外层元素设置 padding 代替 内层元素margin
* 给下边元素设置 `position: absolute;`
* 给下边元素设置 浮动



### display 和 visibility 区别

* `"display: none;"` : 隐藏的元素会让出自己的位置，让底下的元素顶上去。
* `"visibility: hidden;"` : 元素自己会隐藏，但不会让出自己的位置。
* 还可以通过标签的全局属性`"hidden"`隐藏，隐藏后不会占用位置。



### 重绘和回流

* 重绘：不会影响页面布局的操作，例如，改变颜色
* 回流：布局的改变导致需要重新构建，例如，添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变(包括边距、填充、边框、宽度和高度)，内容改变

**回流必将引起重绘，而重绘不一定会引起回流。**



## JS

### 数据类型

基本数据类型：`string number boolean null undefined Symbol`

复杂数据类型：`Object function array`

能转换为false的值：`false，空字符串，0，NaN，undefined，null`



### 判断数据类型

* typeof ：返回数据类型。检测不出 null 和 数组，结果都为 object，所以常用于检测基本数据类型
* instanceof ：判断对象是否是某个类的实例。检测不出基本数据类型，所以常用于检测复杂数据类型。
* constructor ：返回对象的构造器，描述的是其构造函数。null 和 undefined 没有 constructor 方法，因此不能判断。因为 constructor 的指向是可以被改变的，所以这种方式不安全。
* Object.prototype.toString.call() ：全类型都可以判断。

```js
console.log(typeof true)    // boolean
console.log(typeof null)    // object
console.log(typeof String)  // function，能new的说明是构造函数，也就是function
console.log(typeof Math)    // object

var num = 123
console.log([1,2] instanceof Array)       // true
console.log(num instanceof Number)        // false

console.log([1,2].constructor == Array)   // true
console.log([1,2].constructor == Object)  // false
console.log(num.constructor == Number)    // true

console.log(Object.prototype.toString.call([]))   // [object Array]
console.log(Object.prototype.toString.call({}))   // [object Object]
console.log(Object.prototype.toString.call(num))  // [object Number]
console.log(Object.prototype.toString.call(undefined))  // [object Undefined]
```



### new做了什么







### 原型

原型是 function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。

需要注意的是，原型是共用的，原型中的属性一旦发生改变，会影响整个原型链。

利用原型特点和概念，可以提取共有属性。





### 闭包

闭包就是一个绑定了局部变量的函数被保存到了全局中。闭包会导致原有作用域链不释放，造成内存泄露。



**闭包的作用**

* 实现公有变量（函数累加器）
* 可以做缓存（存储结构）
* 可以实现封装，属性私有化
* 模块化开发，防止污染全局变量

```js
// 属性私有化
function Deng(name, wife) {
  var prepareWife = 'xiaozhang'   // 预备役

  this.name = name
  this.wife = wife
  this.divorce = function() {
    this.wife = prepareWife
  }
  // 提供get方法和set方法对私有属性进行操作
  this.changePrepareWife = function(target) {
    prepareWife = target
  }
  this.sayPrepareWife = function() {
    console.log(prepareWife)
  }
}

var deng = new Deng('deng', 'xiaoliu')
console.log(deng.prepareWife)   // undefined  属性私有化，无法直接访问到
```



### 内存泄露有哪些

闭包、意外的全局变量、定时器/回调，保存了dom元素的变量(保存后该元素又被清理掉了)



### 原型链和作用域链

* 原型链：当访问一个对象的某个属性时，会先在这个对象本身的属性上找，如果没有找到，会去这个对象的 `__proto__` 属性上找，直到最顶层，找不到即为 undefined。
* 作用域链：变量取值会到创建这个变量的函数的作用域中取值，如果找不到，就会向上级作用域去找，直到全局作用域。

两者区别：

* 作用域链是对变量而言，原型链是对于对象的属性而言
* 作用域链的顶层是 window，原型链的顶层是 Object



### 数组常用方法

* `length` : 返回数组的长度
* `push(value)` : 入栈，向数组的末尾添加一个或多个元素，并返回数组新的长度
* `pop()` : 出栈，删除并返回数组的最后一个元素
* `shift()` : 将数组的第一个元素删除，并返回被删除的元素
* `unshift(value1 [,value...])` : 向数组的开头添加一个或更多元素，并返回数组新的长度
* toString() : 将数组转换为字符串，并返回结果。数组中的元素之间用逗号分隔。
* join(str) : 用于把数组中的所有元素放入一个字符串中返回，元素通过指定的分隔符str进行分隔。
* `concat(value1 [,value...])` : 用于合并两个或多个数组，此方法**不会更改现有数组**，而是返回一个新数组。参数可以是数组或者值。
* reverse() : 颠倒数组中元素的顺序。此方法**会改变原来的数组**。
* sort() : 用于对数组的元素进行排序并返回排序后的数组。此方法**会改变原来的数组**。
  * 如果没有使用参数，默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列
  * 在默认排序规则下，该方法不会对数组中的`number类型`元素进行大小排序，但是可以使用参数实现。
* `slice(start, end)` : 截取数组(从索引start开始，到索引end-1结束)，并返回一个新的数组。此方法**不会更改现有数组**。
  * start参数 : 数组的索引，从该索引开始提取原数组元素。
    * 如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取
    * 省略该参数则从索引0开始。如果参数超出原数组的索引范围，则返回空数组
  * end参数 : 数组的索引，在该索引处结束提取原数组元素(不包含end)。
    * 如果该参数为负数，则它表示在原数组中的倒数第几个元素结束抽取(还是不包含自己)。
    * 省略该参数则提取到原数组末尾(包括最后一个)
* `splice(start, delCount [,item...])` : 通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。**此方法会改变原数组**。
  * start : 数组索引，用于指定修改的开始位置。
  * delCount : 要删除的元素个数，如果值为0表示不删除元素。
  * item... : 可选，要添加进数组的元素，从start位置开始。如果不指定，则表示只删除数组元素。
  * 返回值 : 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。
* `forEach(callback [,thisArg])` : 对数组的每个元素执行一次给定的函数。返回undefined。`IE9支持`
  * callback 为数组中每个元素执行的函数，该函数接收一至三个参数：
    * v 数组中正在处理的当前元素。
    * i 数组中正在处理的当前元素的索引。
    * a `forEach()` 方法正在操作的数组。
  * thisArg 可选参数。当执行回调函数 `callback` 时，用作 `this` 的值。
    * 如果 `thisArg` 参数有值，则每次 `callback` 函数被调用时，`this` 都会指向 `thisArg` 参数。如果省略了 `thisArg` 参数，或者其值为 `null` 或 `undefined`，`this` 则指向全局对象。
  * **注意: 因为 `forEach()`返回的是undefined，所以不可以链式调用。**
* `filter(callback)` : 创建一个新数组并返回, 其包含通过所提供函数实现的测试的所有元素。如果没有任何数组元素通过测试，则返回空数组。
  * callback 用来测试数组的每个元素的函数。返回 `true` 表示该元素通过测试，保留该元素，`false` 则不保留。它接受以下三个参数：
    * v 数组中当前正在处理的元素。
    * i 正在处理的元素在数组中的索引。
    * a 调用了 `filter()` 的数组本身。
* `map(callback)` : 创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。
  * callback 生成新数组元素的函数，使用三个参数：
    * v 数组中当前正在处理的元素。
    * i 正在处理的元素在数组中的索引。
    * a 调用了 `map()` 的数组本身。
  * 通过map遍历返回的数据形成新数组与原数组之间没有引用关系，并且返回的数组长度和原数组长度是完全相等的。
* flatMap(callback) : 和map()一样，返回一个新的数组，其中每个元素都是回调函数的结果，但它会将结果压缩成一个新数组(扁平化处理)。flatMap 通常在合并成一种方法的效率稍微高一些。
  * callback 生成新数组元素的函数，使用三个参数：同map()方法
  * IE不支持，且需要高版本的浏览器
* reduce(callback [,initialValue]) : 为数组中的每一个元素依次执行`callback`函数，不包括数组中被删除或从未被赋值的元素。将callback的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后返回函数累计处理的结果
  * callback 是执行数组中每个值(如果没有提供 `initialValue则第一个值除外`)的函数，使用四个参数：
    * accumulator : 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或`initialValue`
    * currentValue : 可选，数组中正在处理的元素。
    * currentIndex : 可选，数组中正在处理的当前元素的索引。 如果提供了`initialValue`，则起始索引号为0，否则从索引1起始。
    * array : 调用`reduce()`的数组
  * initialValue : 可选，作为第一次调用 `callback`函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。
  * 回调函数第一次执行时，`accumulator` 和`currentValue`的取值有两种情况：
    * 提供了`initialValue`，`accumulator`取值为`initialValue`，`currentValue`取数组中的第一个值；
    * 没有提供`initialValue`，那么`accumulator`取数组中的第一个值，`currentValue`取数组中的第二个值。
  * **注意：**如果没有提供`initialValue`，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供`initialValue`，从索引0开始。
* `every(callback)` : every() 检测数组中的元素是否符合指定的条件，如果元素都满足则返回true，只要有一个没有满足则false
  * callback 用来测试每个元素的函数，可以接收三个参数: element，index，array
    * element : 用于测试的当前值
    * index : 可选，用于测试的当前值的索引 
    * array : 可选，调用every()的当前数组
  * 注意：若收到一个空数组，此方法在一切情况下都会返回 true。如果当前测试的元素不满足会立刻返回false并结束函数。



### TDO箭头函数

* 普通函数 ：可以通过 `bind call apply` 改变this指向。可以使用 new
* 箭头函数 ：本身没有this指向。
  * this继承上一个函数作用域
  * this 在函数定义的那一刻才确定的



### ES6 新特性

* let const map set Symbol
* promise async await
* 解构赋值，模板字符串，箭头函数，展开运算符





### Promise

Promise 是异步编程的一种解决方案。

Promise 对象有三种状态，pending、resolved、rejected。对象的状态不受外界影响，且一旦状态改变，就不会再变。

在then方法中接受两个回调函数来处理Promise的结果，第一个函数是处理成功的回调，第二个函数是处理失败的回调(可选)。还可以在回调中返回一个新的Promise对象，并在下一个then方法中进行处理，形成多个then方法的链式操作。



Promise 是异步编程的一种解决方案（不会陷入回调地狱）。

Promise 对象的特点:

* 对象的状态不受外界影响。`Promise` 对象代表一个异步操作，有三种状态：`Pending`（进行中）、`Resolved`（已完成）和`Rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
* 一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise` 对象的状态改变，只有两种可能：
  * 从 `Pending` 变为 `Resolved`
  * 从 `Pending` 变为 `Rejected`。



`Promise` 的缺点:

* 无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。
* 如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。
* 当处于`Pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）



#### 用法

ES6规定，Promise对象是一个构造函数，用来生成Promise实例。

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。作用如下:

* `resolve()` 将Promise对象的状态从Pending变为Resolved，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
* `reject()` 将Promise对象的状态从Pending变为Rejected，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

```js
new Promise(function (resolve, reject) {})
```



```js
var promise = new Promise(function(resolve, reject) {
  // 异步操作，例如从服务器获取数据

  if (/* 判断异步操作是否成功 */){
    resolve(value);		// 成功
  } else {
    reject(error);		// 失败
  }
});

// Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。
promise.then(function(value) {
  // 成功的回调
}, function(error) {
  // 失败的回调
});
```



`then` 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。

**注意: 只有当Promise的状态变为resolved或者rejected时，then方法才会被调用。**



#### 示例1

```js
function timeout(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms, 'done');
  });
}

timeout(100).then((value) => {
  console.log(value);	// 'done'
});
```

上面代码中，`timeout`方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（`ms`参数）以后，Promise实例的状态变为Resolved，就会触发`then`方法绑定的回调函数。



#### 示例2

```js
function getImage(src) {
	// 在函数中返回一个 Promise 对象
  return new Promise(function (resolve, reject) {
    let img = new Image();
    img.onload = function () {
      resolve(img);
    };
    img.onerror = function () {
      reject("这是错误的内容");
    };
    img.src = src;
  });
}

// then(执行成功时的处理函数， 执行失败时的处理函数)
// then(执行成功时的处理函数).catch(执行失败时的处理函数)

getImage("images/1.jpg").then(
  function (img) {
    console.log(img);
  },
  function (error) {
    console.log(error);
  }
);

getImage("images/11.jpg")
  .then(function (img) {
    console.log(img);
  })
  .catch(function (error) {
    console.log(error);
  });
```





#### 执行顺序

Promise 被创建后就会立即执行，并且调用resolve或reject后不会终结Promise中参数函数的执行。

```js
let promise = new Promise(function(resolve, reject) {
  console.log('Promise1');
  resolve('完成');
  console.log('Promise2');
});

promise.then(function(value) {
  console.log(value);
});

console.log('Hi!');

// 输出结果:
// Promise1
// Promise2
// Hi!
// Resolved
```



#### Promise.prototype.then()

Promise实例具有`then`方法，也就是说，`then`方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过，`then`方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。

`then`方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。



```js
let promise = new Promise(resolve => {
	resolve('abc')
}).then(value => {
	// 返回一个新的Promise
	return new Promise(resolve => {
		resolve(value.toUpperCase())
	})
})
.then(value => {
	console.log(value)	// ABC
})
```



#### Promise.prototype.catch()

`Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。

当 promise 链中的任何内容失败并引发错误或拒绝 promise 时，则控制权会转到链中最近的 `catch()` 语句。



注意:

* 如果Promise状态已经变成`Resolved`，再抛出错误是无效的。
* 如果已经在`then`中处理了错误，那么就不会再执行`catch`
* `catch`方法返回的还是一个Promise对象，因此后面还可以接着调用`then`方法。

```javascript
new Promise((resolve, reject) => {
  throw new Error('错误')
}).catch(err => {
  console.error(err)
})

// 或

new Promise((resolve, reject) => {
  reject('错误')
}).catch(err => {
  console.error(err)
})
```

**级联错误**：如果在 `catch()` 内部引发错误，则可以附加第二个 `catch()`来处理，依此类推。

```javascript
new Promise((resolve, reject) => {
  throw new Error('错误')
})
  .catch(err => {
    throw new Error('错误')
  })
  .catch(err => {
    console.error(err)
  })
```



#### 链式Promise示例

Promise 可以返回另一个 promise，从而创建一个 promise 链。

```js
getImage("images/1.jpg")
  .then(function (img) {
    console.log(img);
    return getImage("images/2.jpg");
  })
  .then(function (img) {
    console.log(img);
    return getImage("images/3.jpg");
  })
  .then(function (img) {
    console.log(img);
  });
```



链式 promise 的一个很好的示例是 Fetch API，可以用于获取资源，且当资源被获取时将 promise 链式排队进行执行。

Fetch API 是基于 promise 的机制，调用 `fetch()` 相当于使用 `new Promise()` 来定义 promsie。

```javascript
// 链式 promise 的示例
const status = response => {
  if (response.status >= 200 && response.status < 300) {
    return Promise.resolve(response)
  }
  return Promise.reject(new Error(response.statusText))
}

const json = response => response.json()

fetch('/todos.json')
  .then(status)    // 注意，`status` 函数实际上在这里被调用，并且同样返回 promise，
  .then(json)      // 这里唯一的区别是的 `json` 函数会返回解决时传入 `data` 的 promise，
  .then(data => {  // 这是 `data` 会在此处作为匿名函数的第一个参数的原因。
    console.log('请求成功获得 JSON 响应', data)
  })
  .catch(error => {
    console.log('请求失败', error)
  })
```



#### 其他方法

##### Promise.finally()

`finally`方法用于指定不管Promise对象最后状态如何，都会执行的操作。常用来释放资源。

```js
new Promise((resolve, reject) => {
	resolve()
})
.finally(() => {
	console.log('finally')
})
```



##### Promise.all()

Promise.all() 中可以传递一个数组作为参数，数组中放入要执行的Promise异步函数。

当all()中的异步全部完成后，会以数组的形式，统一返回其Promise中resolve()第一个参数的内容。

```js
Promise.all([
  getImage("images/1.jpg"),
  getImage("images/2.jpg"),
  getImage("images/3.jpg"),
]).then(function (list) {
  console.log(list);	// [img, img, img]
});
```



##### Promise.race()

race()用于同时执行多个异步，如果哪个先完成就直接结束，处理这个先完成的。

```js
Promise.race([
  getImage("images/2.jpg"),
  getImage("images/1.jpg"),
  getImage("images/3.jpg"),
]).then(function (img) {
  // race 就是赛跑，这里只返回最先加载的数据
  // 谁的异步最先完成，就返回最先完成的异步
  console.log(img); // <img src="images/2.jpg">
});
```



##### all() 和 race() 区别

all 和 race 异步组都是并列开跑，all是所有的都跑完了才执行then，race谁第一个跑完就执行谁，后面的就不执行了。



### async/await

应用场景演示：

```js
const requestLogin = (params) => {
  return new Promise((resolve) => {
    resolve(`${params.username} 登录成功`);
  });
};

const requestUserInfo = (params) => {
  return new Promise((resolve) => {
    resolve(`${params}，欢迎你`);
  });
};

// 在登录中，需要成功拿到用户登录成功后的信息才能去请求用户信息，使用async/await可以将代码写成同步的样子
const handleLogin = async () => {
  const res = await requestLogin({
    username: "张三",
    password: "123456",
  });

  const info = await requestUserInfo(res);
  console.log(info);
};

handleLogin();
```





### TDO事件委托



### for in 和 for of 的区别

for in 遍历的是索引(key)，for of 遍历的是值(value)

for in 能够遍历数组和对象，for of 只能够遍历 部署了`Iterator`接口的对象(普通对象不行)，比如Map

```js
var arr = ['111', '222', '333']
for(var i in arr){
  console.log(i)  // 0 1 2
}
for(var i of arr){
  console.log(i)  // 111 222 333
}

var obj = {
  name: 'hlw',
  age: 16
}
for(var i in obj){
  console.log(i)  // name age
}
for(var i of obj){
  console.log(i)  // 报错 obj is not iterable
}

var map = new Map()
map.set('first', 'hello')
map.set('second', 'world')

for(let item of map) {
  console.log(item)   // ['first', 'hello']  ['second', 'world']
}
for(let [k,v] of map) {
  console.log(k,v)    // first hello   second world
}
```



### call() 和 apply()

`call()`和`apply()`的作用都是：改变函数中的this指向并执行该函数。区别：传参列表不同。

call和apply在执行时做了两件事:

1. 将函数内部this指向了第一个参数
2. 调用函数



### 函数防抖和函数节流

#### 函数防抖

在一定时间内，一个函数如果被触发多次，但只会执行最后一次，这就叫做函数防抖。

原理: 设置一个定时器，并将要执行的函数放在定时器中。当函数短时间内被调用，清除上一次的定时器，并设置下一次定时器，让这个函数在一定时间内，不会重复执行，只执行最后的一次。

好处: 在一定时间内，函数被多次调用，但只会执行最后一次的调用，大大节约了内存。



应用场景:

* 百度搜索框中，输入文本时会通过AJAX请求，在下拉框中显示联想的内容。当输入文本比较快时，没有必要每个字符都去发送请求，只在用户最后一次输入完，再发送请求。
* 页面的onscroll事件
* 重复点击事件等...

```js
function debounce (callback, delay) {
  var t = null
  return function (e) {
    clearTimeout(t)
    t = setTimeout(() => {
      callback.call(e)
    }, delay);
  }
}

window.onscroll = debounce(function () {
  console.log('调用了1次')
}, 500)

// window.onscroll = function(){
//   console.log('调用了1次')
// }
```



![image-20210828210030914](https://www.huangyihui.cn/upload/gburlimg/c8a07791fd7d.png)



#### 函数节流

在一定时间内，一个函数被触发多次，只执行第一个，不执行后面的。当一定时间过去后，如果这个函数又被多次触发，还是像上面一样，只执行第一个，不执行后面的。以此类推。



原理: 记录现在触发的时间和最后一次触发的时间，当一定时间内，多次触发时，比较现在触发的时间和最后一次触发的时间，如果两次触发的时间还在一定时间内，则不执行这次的触发。



好处: 降低触发频率。和防抖的用途一样

```js
function throttle (callback, duration) {
  // 记录最后一次执行的时间
  var lasttime = new Date().getTime()
  return function () {
    // 记录现在执行的时间
    var now = new Date().getTime()
    if (now - lasttime > duration) {
      // 如果两次执行的时间大于设置的持续时间，才会执行callback方法
      // 并把最后一次执行的时间设置为当前执行的时间
      lasttime = now
      callback()
    }
  }
}

window.onscroll = throttle(function () {
  console.log('调用了1次')
}, 500)
```



![image-20210828214230407](https://www.huangyihui.cn/upload/gburlimg/d35af40e0bf96.png)





#### 区别

防抖是删除前一个，节流是不执行下一个。

防抖: 当函数在短时间内连续触发多次，则立即结束上一次的执行，开始执行最新触发的这次。

节流: 当函数在短时间内连续触发多次，则判断上次开始执行的时间和最新触发这次的时间是否还在特定时间区间内，如果还在时间段内，则不执行最新的这次触发。



### 模拟继承-圣杯模式

```js
// 圣杯模式高级版
var inherit = (function () {
  var F = function () {}
  return function (Target, Origin) {
    F.prototype = Origin.prototype
    Target.prototype = new F()
    Target.prototype.constuctor = Target
    Target.prototype.uber = Origin.prototype
  }
}())

Father.prototype.lastName = 'wang'
function Father() {}
function Son() {}

// 继承之后，Son就有了Father的prototype，但两者并不是共享关系，修改原型时互不影响。
inherit(Son, Father)
Son.prototype.lastName = 'zhang'

var son = new Son()
var father = new Father()
```





### 深浅拷贝

浅拷贝: 可以将对象的最外层属性(基本数据类型)全部复制，里层属性(引用数据类型)仍然是引用关系

深拷贝: 完全将对象复制一份，并且新对象中的所有属性和原对象都没有关系



#### 浅复制

```js
var obj = {
  a: 1,
  b: 2,
  c: [20, 30, 50],
  d: {
    n: 10,
    m: 20
  }
}

var newObj = {}
// 浅拷贝
for (var key in obj) {
  newObj[key] = obj[key]
}

// 浅拷贝的缺点: 引用数据类型的属性仍然是引用关系，一个对象修改，另一个对象也会受到影响
newObj.c[0] = 99
obj.d.n = 0
console.log(obj, newObj)
```



#### 深拷贝

JSON方式虽然可以快速完成深拷贝，但是对于get,set方法和不可遍历属性，是复制不了的

```js
var obj = {
  a: 1,
  b: 2,
  c: [20, 30, 50],
  d: {
    n: 10,
    m: 20
  },
  set f(value) {
    this.a = value
  },
  get f() {
    return this.a
  }
}

// JSON方式虽然可以快速完成深拷贝，但是对于get,set方法和不可遍历属性，是复制不了的
Object.defineProperty(obj, 'z', {value:10})

// 深拷贝可以使用JSON的方式，因为将obj转换成JSON格式的字符串后，变成了基本数据类型，就没有引用关系
// 接着将字符串又转换成JSON对象，完成了深拷贝
var newObj = JSON.parse(JSON.stringify(obj))

// 深拷贝后，一个对象属性的修改不会影响到另一个对象
newObj.c[0] = 99
obj.d.n = 0
console.log(obj, newObj)
```



实现终极深拷贝

```js
var obj = {
  a: 1,
  b: 2,
  c: [20, 30, 50],
  d: {
    n: 10,
    m: 20
  },
  set f(value) {
    this.a = value
  },
  get f() {
    return this.a
  }
}

var newObj = {}

Object.defineProperty(obj, 'z', {value:10})

cloneObject(newObj, obj)
function cloneObject(target, source) {
  // 获取对象下的所有属性，包括不可遍历属性
  var names = Object.getOwnPropertyNames(source)

  for (var i = 0; i < names.length; i++) {
    var desc = Object.getOwnPropertyDescriptor(source, names[i])
    if (typeof(desc.value) === 'object' && desc.value !== null) {
      // 如果属性是引用类型，则判断是数组还是对象并设置为空的数组或对象
      var obj
      if (Array.isArray(desc.value)) {
        obj = []
      } else {
        obj = {}
      }

      Object.defineProperty(target, names[i], {
        configurable: desc.configurable,  // 不可删除
        enumerable: desc.enumerable,      // 是否可遍历
        value: obj,                       // 值
        writable: desc.writable           // 是否可修改
      })
      cloneObject(obj, desc.value)
    } else {
      Object.defineProperty(target, names[i], desc)
    }
  }
}

// 深拷贝后，一个对象属性的修改不会影响到另一个对象
newObj.c[0] = 99
obj.d.n = 0
console.log(obj, newObj)
```



### 微任务和宏任务

JS是事件驱动程序，因此最底层都是以事件驱动完成函数的回调执行。例如当有触发某个事件的启动因素时，就会抛出事件，调用回调函数，但是这个过程并不是函数可以自己去回调，而是抛出事件后，将在任务队列中等待下一个执行时间，立即调用函数。



**任务队列**

即使在同一个任务队列中，也有先后执行的顺序，主要分为宏观任务和微观任务。

* 宏观任务: setTimeout、setInterval
  * 是在当前任务队列的尾部抛出事件，等待下一次任务队列执行时间开始的时候执行
* 微观任务: process、nextTick、Promise
  * 一般是在当前任务队列的尾部，下一次任务队列执行时间之前执行

这样任务队列就在一个个时间段内不停的循环执行下去。

```js
console.log('a')

setTimeout(() => {
  console.log('b')
}, 0)

new Promise((res, rej) => {
  res()
}).then(() => {
  console.log('c')
})

console.log('d')
//结果是a d c b
```

为什么结果是a d c b 呢?

因为a, d是同步队列，会第一时间执行，c是异步中的微观任务，在同步任务队列执行完毕后，就接着执行。而b是异步中的宏观任务，需要在下一次任务队列开始的时候执行。



### 事件委托

事件委托就是自身不对事件进行处理，而是将事件交给父级处理。在事件处理中，通过判断触发事件的目标对象，再进行相应的处理。

```html
<ul id="list">
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>

<script>
  var ul = document.getElementById('list')
  ul.onclick = function(e) {
    var event = e || window.event   // 获取event对象
    var target = event.target || event.srcElement   // 获取触发事件的目标对象
    if(target.nodeName.toLowerCase() == 'li'){      // 判断目标对象是不是li
      console.log(target.innerText)
    }

    // 简写
    // if(e.target.nodeName.toLowerCase() == 'li') console.log(e.target.innerText)
  }
</script>
```



### 跨域

在开发过程中，经常会出现需要访问别人的服务器，从第三方拉取数据，但是受到W3C的同源策略影响，并不能正常获取到数据。

为了解决这个问题，就产生了以下这几种方案。



#### 同源策略

同源策略（Same origin policy）是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。

同源是指**"协议+域名+端口"三者相同**，即便两个不同的域名指向同一个 ip 地址，也非同源。

同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收。



#### JSONP

JSONP(JSON with Padding)是JSON的一种"使用模式"，理解为一个包裹着的json，可用于解决主流浏览器的跨域数据访问的问题。



原理: 利用`<script>`标签的`src属性`可以请求一个非同源的地址的特性，请求成功后会将响应的内容当成js代码直接运行。因为`<script>`标签本来就是加载后会自动运行的。

所以，可以在服务端的响应中填充需要获取的数据，并通过在URL中指定处理数据的方法。当响应成功后，就可以拿到需要的数据了。



```html
<!-- 客户端index.html -->
<script>
  // 创建方法用来接受和处理返回的数据
  function getData(data){
    console.log(data)
  }
</script>
<script src="http://localhost:8080/api/data?cb=getData"></script>
```

```js
// 服务端server.js
const http  = require('http')
const url = require('url')

const server = http.createServer((req, res) => {
  let urlStr = req.url
  let urlObj = url.parse(urlStr, true)  // 将请求的URL解析成对象
  // console.log(urlObj)
  switch(urlObj.pathname){
    case '/api/data':
      // 客户端会把返回的内容当成js代码直接运行
      res.write(`${urlObj.query.cb}("hello")`)	// 等同于运行getData()
      break
    default:
      res.write('page not found')
  }
  res.end()
})

server.listen(8080, ()=>{
  console.log('localhost:8080')
})
```





#### CORS

CORS是一个W3C标准，全称是"跨域资源共享"(Cross-origin resource sharing)。CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

实现CORS通信的关键是服务器，只要服务器实现了CORS接口，就可以跨源通信。



浏览器禁止非同源访问，如果在头信息中设置了哪些源可以访问，浏览器检测到则不阻拦，解决同源策略。

原理: 在服务端设置响应头为 `'Access-Control-Allow-Origin' : '*'` 

```html
<!-- 客户端index.html -->
<script>
  fetch('http://localhost:8080/api/data')
    .then(response => response.json())
    .then(result => console.log(result))
</script>
```

```js
// 服务端server.js
const http  = require('http')
const url = require('url')

const server = http.createServer((req, res) => {
  let urlStr = req.url
  let urlObj = url.parse(urlStr, true)  // 将请求的URL解析成对象
  console.log(urlObj)
  switch(urlObj.pathname){
    case '/api/data':
      // 设置响应头
      res.writeHead(200, {
        'content-type': 'application/json;charset=utf-8',
        'Access-Control-Allow-Origin' : '*'
      })
      res.write('{"ret": true, "data": "hello"}')
      break
    default:
      res.write('page not found')
  }
  res.end()
})

server.listen(8080, ()=>{
  console.log('localhost:8080')
})
```



CORS请求默认不发送Cookie和HTTP认证信息，如果要把Cookie发到服务器，一方面要服务器同意，指定 `Access-Control-Allow-Credentials` 字段。另一方面，开发者必须在AJAX请求中打开 `withCredentials` 属性。否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。

```js
// 服务端
res.writeHead(200, {
	// 设置可以资源共享的路径是谁(访问-控制-允许-来源)，*表示允许全部来源地址
  'Access-Control-Allow-Origin' : '*',
  // 设置认证信息，作用:携带Cookie
  'Access-Control-Allow-Credentials' : 'true'
})
```

```js
// 浏览器
// 如果服务器已经让携带Cookie，浏览器还是不会携带必须添加认证信息。浏览器再次访问才会携带Cookie
xhrFields: {
	withCredentials: true
}
```





#### 第三方插件

在NodeJS中可以通过中间件 `http-proxy-middleware` 实现正向代理。

1、安装 `http-proxy-middleware` 

```bash
npm install http-proxy-middleware
```

2、配置正向代理

```js
const http  = require('http')
const { createProxyMiddleware} = require('http-proxy-middleware')

const server = http.createServer((req, res) => {
  let url = req.url

  if(/\/api/.test(url)){
    const proxy = createProxyMiddleware('/api', {
      target: 'https://www.huangyihui.cn:',
      changeOrigin: true
    })

    proxy(req, res)
  }else{
    console.log('error')
  }
  
})

server.listen(8080, ()=>{
  console.log('localhost:8080')
})
```







## Vue





## Webpack



## 网络

### HTTP状态码

* 1开头：信息
* 2开头：成功
  * **200：成功**
  * 201：成功创建资源。例如创建新用户。
  * 204：成功，但无内容返回。例如删除成功。
* 3开头：成功-重定向
  * 301：永久重定向
  * 302：临时重定向
* 4开头：客户端错误（前端问题）
  * **400：客户端请求的语法错误。通常是请求参数错误（路径、查询参数、请求头、请求体）**
  * 401：用户身份验证失败
  * 403：用户身份验证通过，但没权限
  * **404：请求的资源找不到。原因可能是资源不存在或者接口请求路径不对**
* 5开头：服务端错误（后端问题）
  * **500：服务器内部错误**
  * 502：服务端配置错误
  * 503：服务器超载了



## 算法

### 数组去重

```js
const arr = [1, 2, 3, 3, 2, 4, 1];
// 方式1：通过判断该项在数组中出现的位置来确定是否重复
const newArr = arr.filter((item, index, list) => list.indexOf(item) === index);
// 方式2：通过Set去除重复项，并使用展开运算符将其转为数组
const resArr = [...new Set(arr)];

console.log(newArr);	// [ 1, 2, 3, 4 ]
console.log(resArr);	// [ 1, 2, 3, 4 ]
```

```js
const arr = [
  { name: "小红" },
  { name: "小明" },
  { name: "小红" },
  { name: "小明" },
  { name: "小张" },
];

// 方式1：通过给空对象添加属性的方式来判断该项是否已存在
const obj = {};
const newArr = [];:
for (let i = 0; i < arr.length; i++) {
  if (!obj[arr[i].name]) {
    newArr.push(arr[i]);
    obj[arr[i].name] = true;
  }
}

// 方式2：通过给空对象添加属性的方式来判断该项是否已存在
const obj = {};
const newArr = arr.reduce((prev, curr) => {
  if (!obj[curr.name]) {
    prev.push(curr);
    obj[curr.name] = true;
  }
  return prev;
}, []);

console.log(newArr);  // [ { name: '小红' }, { name: '小明' }, { name: '小张' } ]
console.log(obj)      // { '小红': true, '小明': true, '小张': true }
```



